"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function T(t,r="children",e){return t.reduce((o,n)=>{const f=o.concat(n,Array.isArray(n[r])&&n[r].length?T(n[r],r,e):[]);return typeof e=="function"&&e(n),f},[])}function A(t=[],r,e="children"){let o=null;return t.some(n=>r(n)?(o=n,!0):o=A(n[e],r,e)),o}function l(t=[],r="children",e="$parent",o=null){return t.map((n,f)=>{const p={...n};return p.$index=f,p[e]=o,p[r]=l(n[r],r,e,p),p})}function b(t,r="$parent"){const e=[t];for(;t=t[r];)e.unshift(t);return e}function E(t,r,e="children"){return t.filter(r).map(o=>({...o,[e]:E(o[e],r,e)}))}function P(t,r,e,o,n=",",f=t.length,p=!0){if(p){if(!Array.isArray(t))throw new TypeError("arg1：keys must be an Array!");if(!Array.isArray(r))throw new TypeError("arg2：arr must be an Array!");if(e&&typeof e!="function")throw new TypeError("arg3：callback must be a function!");if(o&&typeof o!="function")throw new TypeError("arg4：callbackAll must be a function!");if(n&&typeof n!="string")throw new TypeError("arg5：join must be a string!");if(f&&typeof f!="number")throw new TypeError("arg6：num must be a number!")}const h=f-1,y=t[h],m=[],g={},c=Array.isArray(y),a={};for(let i=r.length-1;i>=0;i--){const u=r[i];let s=u[y];o&&o(u,i),c&&(s=y.map(d=>u[d]).join(n)),g[s]?(g[s].push(u),e&&e(u,a[s])):(g[s]=[u],e&&e(u,a[s]={}))}const w=Object.keys(g);for(let i=w.length-1;i>=0;i--){const u=w[i],s={key:c?u.split(n):u,value:h!==0?P(t,g[u],e,null,n,h,!1):g[u]};e&&Object.assign(s,a[u]),m.push(s)}return m}function v(t,r){for(let e=t.length-1;e>=0;e--)r(t[e],e)}function x(t,r,e){let o=t[r];t[r]=t[e],t[e]=o}exports.exchangeArrP=x;exports.filterTree=E;exports.findTreeItem=A;exports.flatWithKey=T;exports.getTreePath=b;exports.groupBy=P;exports.reverseForEach=v;exports.treeItemSetParent=l;

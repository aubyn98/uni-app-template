"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function T(t,r="children",e){return t.reduce((o,n,s)=>{const h=o.concat(n,Array.isArray(n[r])&&n[r].length?T(n[r],r,e):[]);return typeof e=="function"&&e(n,s),h},[])}function A(t=[],r,e="children"){let o=null;return t.some((n,s)=>r(n,s)?(o=n,!0):o=A(n[e],r,e)),o}function l(t=[],r="children",e="$parent",o=null,n="$index"){return t.map((s,h)=>{const i={...s};return i[n]=h,i[e]=o,i[r]=l(s[r],r,e,i,n),i})}function d(t,r="$parent"){const e=[t];for(;t=t[r];)e.unshift(t);return e}function E(t,r,e="children"){return t.filter(r).map(o=>({...o,[e]:E(o[e],r,e)}))}function P(t,r,e,o,n=",",s=t.length,h=!0){if(h){if(!Array.isArray(t))throw new TypeError("arg1：keys must be an Array!");if(!Array.isArray(r))throw new TypeError("arg2：arr must be an Array!");if(e&&typeof e!="function")throw new TypeError("arg3：callback must be a function!");if(o&&typeof o!="function")throw new TypeError("arg4：callbackAll must be a function!");if(n&&typeof n!="string")throw new TypeError("arg5：join must be a string!");if(s&&typeof s!="number")throw new TypeError("arg6：num must be a number!")}const i=s-1,a=t[i],m=[],g={},c=Array.isArray(a),y={};for(let p=r.length-1;p>=0;p--){const u=r[p];let f=u[a];o&&o(u,p),c&&(f=a.map(b=>u[b]).join(n)),g[f]?(g[f].push(u),e&&e(u,y[f])):(g[f]=[u],e&&e(u,y[f]={}))}const w=Object.keys(g);for(let p=w.length-1;p>=0;p--){const u=w[p],f={key:c?u.split(n):u,value:i!==0?P(t,g[u],e,null,n,i,!1):g[u]};e&&Object.assign(f,y[u]),m.push(f)}return m}function v(t,r){for(let e=t.length-1;e>=0;e--)r(t[e],e)}function I(t,r,e){let o=t[r];t[r]=t[e],t[e]=o}exports.exchangeArrP=I;exports.filterTree=E;exports.findTreeItem=A;exports.flatWithKey=T;exports.getTreePath=d;exports.groupBy=P;exports.reverseForEach=v;exports.treeItemSetParent=l;

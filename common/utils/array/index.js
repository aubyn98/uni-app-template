"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});function T(t,r="children",e){return t.reduce((o,n)=>{const s=o.concat(n,Array.isArray(n[r])&&n[r].length?T(n[r],r,e):[]);return typeof e=="function"&&e(n),s},[])}function A(t=[],r,e="children"){let o=null;return t.some((n,s)=>r(n,s)?(o=n,!0):o=A(n[e],r,e)),o}function l(t=[],r="children",e="$parent",o=null){return t.map((n,s)=>{const p={...n};return p.$index=s,p[e]=o,p[r]=l(n[r],r,e,p),p})}function b(t,r="$parent"){const e=[t];for(;t=t[r];)e.unshift(t);return e}function E(t,r,e="children"){return t.filter(r).map(o=>({...o,[e]:E(o[e],r,e)}))}function P(t,r,e,o,n=",",s=t.length,p=!0){if(p){if(!Array.isArray(t))throw new TypeError("arg1：keys must be an Array!");if(!Array.isArray(r))throw new TypeError("arg2：arr must be an Array!");if(e&&typeof e!="function")throw new TypeError("arg3：callback must be a function!");if(o&&typeof o!="function")throw new TypeError("arg4：callbackAll must be a function!");if(n&&typeof n!="string")throw new TypeError("arg5：join must be a string!");if(s&&typeof s!="number")throw new TypeError("arg6：num must be a number!")}const h=s-1,y=t[h],m=[],g={},c=Array.isArray(y),a={};for(let f=r.length-1;f>=0;f--){const u=r[f];let i=u[y];o&&o(u,f),c&&(i=y.map(d=>u[d]).join(n)),g[i]?(g[i].push(u),e&&e(u,a[i])):(g[i]=[u],e&&e(u,a[i]={}))}const w=Object.keys(g);for(let f=w.length-1;f>=0;f--){const u=w[f],i={key:c?u.split(n):u,value:h!==0?P(t,g[u],e,null,n,h,!1):g[u]};e&&Object.assign(i,a[u]),m.push(i)}return m}function v(t,r){for(let e=t.length-1;e>=0;e--)r(t[e],e)}function x(t,r,e){let o=t[r];t[r]=t[e],t[e]=o}exports.exchangeArrP=x;exports.filterTree=E;exports.findTreeItem=A;exports.flatWithKey=T;exports.getTreePath=b;exports.groupBy=P;exports.reverseForEach=v;exports.treeItemSetParent=l;
